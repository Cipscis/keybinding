{"version":3,"sources":["webpack://keybinding/./keybinding.js","webpack://keybinding/./docs/assets/js/src/main.js"],"names":["keys","bindings","module","_isFocusOnInput","$activeEl","document","activeElement","nodeName","toLowerCase","isInput","includes","inputType","attributes","type","value","isContentEditable","_bindFn","key","fn","fnWrapper","addEventListener","push","bind","allowInInput","requireCtrl","TypeError","event","ctrlKey","apply","this","arguments","preventDefault","stopPropagation","unbind","binding","index","length","removeEventListener","splice","_getSequenceArgs","keyA","keyB","keyC","args","Array","prototype","call","isArray","bindSequence","keysPressed","shift","i","keyString","join","unbindSequence","setMessage","message","e","querySelector","textContent","konamiCode","cheat","kPress"],"mappings":"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","file":"bundle.js","sourcesContent":["const keys = (function () {\n\tconst bindings = {};\n\t/*\n\t{\n\t\t[keyString]: [\n\t\t\t{\n\t\t\t\tfn: fnA,\n\t\t\t\tfnWrapper: fnWrapperA\n\t\t\t},\n\t\t\t{\n\t\t\t\tfn: fnB,\n\t\t\t\tfnWrapper: fnWrapperB\n\t\t\t}\n\t\t]\n\t}\n\t*/\n\n\tconst module = {\n\t\t_isFocusOnInput: function () {\n\t\t\t// Check if the current active element is an input that accepts keypresses\n\n\t\t\tlet $activeEl = document.activeElement;\n\t\t\tlet nodeName = $activeEl.nodeName.toLowerCase();\n\n\t\t\tlet isInput = (['input', 'textarea', 'select'].includes(nodeName));\n\n\t\t\tif (nodeName === 'input') {\n\t\t\t\tlet inputType = $activeEl.attributes.type.value.toLowerCase();\n\n\t\t\t\tif (['color', 'radio', 'checkbox'].includes(inputType)) {\n\t\t\t\t\tisInput = false;\n\t\t\t\t}\n\t\t\t} else if ($activeEl.isContentEditable) {\n\t\t\t\tisInput = true;\n\t\t\t}\n\n\t\t\treturn isInput;\n\t\t},\n\n\t\t_bindFn: function (key, fn, fnWrapper) {\n\t\t\tdocument.addEventListener('keydown', fnWrapper);\n\t\t\tif (!bindings[key]) {\n\t\t\t\tbindings[key] = [];\n\t\t\t}\n\n\t\t\tbindings[key].push({\n\t\t\t\tfn: fn,\n\t\t\t\tfnWrapper: fnWrapper\n\t\t\t});\n\t\t},\n\n\t\tbind: function (key, fn, allowInInput, requireCtrl) {\n\t\t\tif (typeof key !== 'string') {\n\t\t\t\tthrow new TypeError('The key parameter to bind must be a string.');\n\t\t\t} else {\n\t\t\t\tkey = key.toLowerCase();\n\t\t\t}\n\n\t\t\tlet fnWrapper = function (event) {\n\t\t\t\t// Don't check key if focus is on an input element,\n\t\t\t\t// unless it is allowed or requires Ctrl\n\t\t\t\tif (!allowInInput && module._isFocusOnInput() && !requireCtrl) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Some behaviour, like selecting an autocomplete result, can\n\t\t\t\t// fire a keydown event with no key\n\t\t\t\tif (event.key && event.key.toLowerCase() === key) {\n\t\t\t\t\tif (!requireCtrl || event.ctrlKey) {\n\t\t\t\t\t\tif (fn.apply(this, arguments) === false) {\n\t\t\t\t\t\t\t// Implement jQuery-like shorthand of return false;\n\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tmodule._bindFn(key, fn, fnWrapper);\n\t\t},\n\n\t\tunbind: function (key, fn) {\n\t\t\tlet binding = bindings[key];\n\t\t\tif (binding) {\n\t\t\t\t// Find index\n\t\t\t\tlet index;\n\t\t\t\tfor (index = 0; index < binding.length; index++) {\n\t\t\t\t\tif (binding[index].fn === fn) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (index < binding.length) {\n\t\t\t\t\tdocument.removeEventListener('keydown', binding[index].fnWrapper);\n\t\t\t\t\tbinding.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t_getSequenceArgs: function (keyA, keyB, keyC, fn) {\n\t\t\tlet args = Array.prototype.splice.call(arguments, 0);\n\t\t\tlet keys = args[0];\n\t\t\tfn = args[args.length-1]; // The function should be the last event\n\n\t\t\tif (!Array.isArray(keys)) {\n\t\t\t\tkeys = args.splice(0, args.length-1);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tkeys,\n\t\t\t\tfn\n\t\t\t};\n\t\t},\n\n\t\tbindSequence: function (keyA, keyB, keyC, fn) {\n\t\t\tlet args = module._getSequenceArgs.apply(this, arguments);\n\t\t\tlet keys = args.keys;\n\n\t\t\tlet keysPressed = [];\n\n\t\t\tfn = args.fn;\n\n\t\t\tif (keys.length > 1) {\n\t\t\t\t// Record as many of the past keys pressed as required for the sequence\n\n\t\t\t\tlet fnWrapper = function (event) {\n\t\t\t\t\tlet key = event.key.toLowerCase();\n\n\t\t\t\t\t// Don't check key presses if focus is on an input element\n\t\t\t\t\tif (module._isFocusOnInput()) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key !== 'shift') {\n\t\t\t\t\t\t// Ignore shift, as it's used as a modifier\n\t\t\t\t\t\tkeysPressed.push(key);\n\t\t\t\t\t}\n\t\t\t\t\tif (keysPressed.length > keys.length) {\n\t\t\t\t\t\tkeysPressed.shift();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (key === keys[keys.length-1]) {\n\t\t\t\t\t\t// When the final key is pressed, check if the whole sequence matches\n\t\t\t\t\t\tlet i;\n\t\t\t\t\t\tfor (i = 0; i < keys.length; i++) {\n\t\t\t\t\t\t\tif (keys[i] !== keysPressed[i]) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// i only reaches keys.length if the break; line was never executed\n\t\t\t\t\t\tif (i === keys.length) {\n\t\t\t\t\t\t\tif (fn.apply(this, arguments) === false) {\n\t\t\t\t\t\t\t\t// Implement jQuery-like shorthand of return false;\n\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tlet keyString = keys.join(',');\n\t\t\t\tmodule._bindFn(keyString, fn, fnWrapper);\n\t\t\t}\n\t\t},\n\n\t\tunbindSequence: function (keyA, keyB, keyC, fn) {\n\t\t\tlet args = module._getSequenceArgs.apply(this, arguments);\n\t\t\tlet keyString = args.keys.join(',');\n\n\t\t\tfn = args.fn;\n\n\t\t\tmodule.unbind(keyString, fn);\n\t\t},\n\t};\n\n\treturn {\n\t\tbind: module.bind,\n\t\tunbind: module.unbind,\n\n\t\tbindSequence: module.bindSequence,\n\t\tunbindSequence: module.unbindSequence,\n\t};\n})();\n\nexport const {\n\tbind,\n\tunbind,\n\n\tbindSequence,\n\tunbindSequence,\n} = keys;\n","import {\n\tbind,\n\tunbind,\n\n\tbindSequence,\n\tunbindSequence,\n} from '/keybinding.js';\n\nconst setMessage = (message) => {\n\treturn (e) => {\n\t\te.preventDefault();\n\n\t\tconst $el = document.querySelector('.js-text-message');\n\t\t$el.textContent = message;\n\t};\n};\n\nconst konamiCode = ['arrowup', 'arrowup', 'arrowdown', 'arrowdown', 'arrowleft', 'arrowright', 'arrowleft', 'arrowright', 'b', 'a' ,'enter'];\nconst cheat = setMessage('Hey, stop cheating!');\n\nbind('a', setMessage('You pressed the \\'a\\' key'));\nbind('m', setMessage('You pressed Ctrl + \\'m\\''), true, true);\n\nbindSequence(konamiCode, cheat);\n\ndocument.querySelector('.js-unbind-sequence').addEventListener('click', (e) => unbindSequence(konamiCode, cheat));\n\nconst kPress = setMessage('You pressed the \\'k\\' key');\ndocument.querySelector('.js-bind').addEventListener('click', (e) => bind('k', kPress, true));\ndocument.querySelector('.js-unbind').addEventListener('click', (e) => unbind('k', kPress));\n"],"sourceRoot":""}